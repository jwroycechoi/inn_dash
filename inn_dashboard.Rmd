---
title: "INN Audience Segment Dashboard"
output:
  flexdashboard::flex_dashboard:
    orientation: columns
    theme:
      version: 4
      bootswatch: yeti
runtime: shiny
---


```{r global, include=FALSE}
library(shiny)
library(tidyverse)
library(sf)
library(leaflet)
library(pals)
library(RColorBrewer)
library(DT)
library(highcharter)
library(tigris)
options(tigris_use_cache = T)
library(rmapshaper)
library(kableExtra)

# Read in data and subset for the selected area
load("data/data.rda")

# Define the list of available metros
metrolookup <- sort(unique(na.omit(metroshape$NAME)))
lookup <- sort(unique(na.omit(full_mapdat$statecode)))

# Define colors for mapping
set.seed(12345)
alphabet_pal <- alphabet()
newPal <- grDevices::colorRampPalette(colors = alphabet_pal)(25)
names(newPal) <- levels(factor(full_mapdat$myclus))
factpal <- colorFactor(newPal, full_mapdat$myclus)

# Define map popup labels
# Define map popup labels
full_mapdat$labels <- paste0(
  "<strong> ZIP: </strong> ",
  full_mapdat$zcta, "<br/>",
  "<strong> Cluster: </strong> ",
  full_mapdat$myclus, "<br/>",
  "<strong> Population: </strong> ",
  full_mapdat$pop_2021, "<br/>",
  "<strong> Income: </strong> $ ",
  full_mapdat$medHHincome_2021
) %>% 
  lapply(HTML)


```

Sidebar {.sidebar}
=================================================

#### Audience Market Segments

The segments are based on various set of demographic, socioeconomic status variables at the ZIP code level. See [Methods] for more details. 

**Please select a metropolitan area of interest from below.** 

**Click on a ZIP code** to see additional information of the ZIP code. You can freely browse the map to explore specific ZIP Codes.

##### Select Metro Area

```{r}
# Define metro area
# selectInput("state", label = "Select a State", choices = lookup,
#             selected = "IL")
selectInput("metroname", label = "Select a Metro Area", choices = metrolookup,
            selected = "Chicago-Naperville-Evanston, IL")
```

Explore Market Segments
=================================================

Column
-------------------------------------------------

### Map

```{r}
# Reactive subset
# sub_mapdat <- reactive({
#   full_mapdat %>% 
#     filter(statecode == input$state)
# })

sub_mapdat <- reactive({
  metroshape %>% 
    filter(NAME == input$metroname)
})

# Create map
output$map <- renderLeaflet({
  bbox <- st_bbox(sub_mapdat()) %>% as.vector()
  # Create leaflet object
  leaflet() %>% 
    addProviderTiles("CartoDB.Positron") %>% 
    addPolygons(data = full_mapdat,
                fillColor = ~factpal(myclus),
                color = "white",
                weight = 0.5,
                smoothFactor = 0,
                fillOpacity = 0.7,
                layerId = ~zcta,
                label = ~labels,
                group = "fullclus",
                highlight = highlightOptions(
                  color = "cyan",
                  bringToFront = T)) %>% 
    setView(lng = (bbox[1] + bbox[3]) / 2,  # Center of the bounding box
            lat = (bbox[2] + bbox[4]) / 2,  # Center of the bounding box
            zoom = 10) %>% 
    addLegend(pal = factpal, values = full_mapdat$myclus, title = "Segments", group = "fullclus")
})


# Click event for the map (used to generate table/chart)
click_zip <- eventReactive(input$map_shape_click, {

  x <- input$map_shape_click

  y <- x$id

  return(y)
})

# Observe clicks
observeEvent(input$map_shape_click, {
  # Create reactive storing layerid of clicked zips
  zip_ids <- reactive({
    eventdata <- input$map_shape_click
    if (is.null(eventdata)) {
      return(NULL) # do nothing
    } else {
      zips <- eventdata$id
      return(zips)
    }
  })
  # Create leaflet proxy
  
  # Subset the clicked zipcode
  sub <- filter(full_mapdat, zcta %in% zip_ids())
  # Get boundaries for selected zip
  bbox2 <- st_bbox(sub)
  xrange <- bbox2$xmax - bbox2$xmin
  yrange <- bbox2$ymax - bbox2$ymin
  bbox2[1] <- bbox2[1] - xrange
  bbox2[2] <- bbox2[2] - yrange
  bbox2[3] <- bbox2[3] + xrange
  bbox2[4] <- bbox2[4] + yrange
  bbox2 <- bbox2 %>% as.vector()
  
  proxy <- leafletProxy("map")
  # Clear old selection on map, and add new selection
  proxy %>%
    clearGroup(group = "sub") %>%
    addPolygons(data = sub, fill = F, color = "#FFFF00",
                opacity = 1, group = "sub", weight = 5) %>% 
    fitBounds(lng1 = bbox2[1],
              lat1 = bbox2[2],
              lng2 = bbox2[3],
              lat2 = bbox2[4])

})

zip_data <- reactive({
  # Fetch data for the clicked zip
  return(filter(full_mapdat, zcta == click_zip()))
})

leafletOutput("map")



```

### Digital Profile Table

```{r}
# Create reactive subset data
metro_sub <- reactive({
  submsa <- zip_data()$msa
  metsub <- full_mapdat %>% 
    filter(msa == submsa) %>% 
    select(zcta, myclus, medHHincome_2021, popPctCh, bbsub_none, bbsub_onlycell, dv_onlycell) %>% 
    st_drop_geometry() %>%
    mutate(across(c(starts_with("bbsub"), popPctCh, dv_onlycell), ~ .x / 100))
  return(metsub)
})

# output$dt <- renderDataTable({
#   
#   dt <- full_mapdat %>% 
#     select(zcta, myclus, medHHincome_2021, popPctCh, bbsub_none, bbsub_onlycell, dv_onlycell) %>% 
#     st_drop_geometry() %>% 
#     mutate(across(c(starts_with("bbsub"), popPctCh, dv_onlycell), ~ .x / 100))
#   
#   datatable(dt, rownames = F,
#             colnames = c("Zip Code", "Segment", "Income", "Population Change", "No Broadband Subscription",
#                                                  "Only Mobile Broadband Subscriptions", "Only Smartphone"),
#             options = list(pageLength = 10)) %>% 
#     formatPercentage(4:7) %>% formatCurrency(3, digits = 0)
#   
# })

output$dt <- renderDataTable({
  
  # dt <- metro_sub() %>% 
  #   select(zcta, myclus, medHHincome_2021, popPctCh, bbsub_none, bbsub_onlycell, dv_onlycell) %>% 
  #   st_drop_geometry() %>%
  #   mutate(across(c(starts_with("bbsub"), popPctCh, dv_onlycell), ~ .x / 100))
  # 
  datatable(metro_sub(), rownames = F,
            colnames = c("Zip Code", "Segment", "Income", "Population Change", "No Broadband Subscription",
                                                 "Only Mobile Broadband Subscriptions", "Only Smartphone"),
            options = list(pageLength = 10)) %>% 
    formatPercentage(4:7) %>% formatCurrency(3, digits = 0)
  
})

dataTableOutput("dt")

```

Column
-------------------------------------------------

### Race/Ethnic Profile, selected Zip code, Segment, and Metro Average (click on the map to show chart)

```{r}
output$raceplot <- renderHighchart({
  
  zd <- zip_data()
  
  # Set up metro data
  metro_data <- full_mapdat %>% st_drop_geometry() %>% 
    filter(metro_group == zd$metro_group) %>% 
    group_by(metro_group) %>% 
    summarise(across(c(starts_with("race") & ends_with("2021"), lessthan9_2021, highschool_2021,
                       college_2021, bachelor_2021, graduate_2021), ~ round(mean(.x, na.rm = T), 1)))
    
  # Set up segment data
  clus_data <- full_mapdat %>% st_drop_geometry() %>% 
    filter(myclus == zd$myclus) %>% 
    group_by(myclus) %>% 
    summarise(across(c(starts_with("race") & ends_with("2021"), lessthan9_2021, highschool_2021,
                       college_2021, bachelor_2021, graduate_2021), ~ round(mean(.x, na.rm = T), 1)))
    
  
  chart <- highchart() %>% 
    hc_chart(type = "column") %>% 
    hc_xAxis(categories = c("White", "Black", "Hispanic", "Asian", "Native", "Pacific-Islander", "Other"),
             title = list(text = 'Race/ethnicity')) %>% 
    hc_yAxis(title = list(text = "%")) %>% 
    hc_plotOptions(series = list(dataLabels = list(enabled = T))) %>% 
    hc_add_series(name = paste0("Zip Code = ", as.character(zd$zcta)),
                  data = c(zd$race_white_2021,
                           zd$race_black_2021,
                           zd$race_hisp_2021,
                           zd$race_asian_2021,
                           zd$race_native_2021,
                           zd$race_pacific_2021,
                           zd$race_other_2021)) %>% 
    hc_add_series(name = paste0("Metro Group Average ", as.character(zd$metro_group)),
                  data = c(metro_data$race_white_2021,
                           metro_data$race_black_2021,
                           metro_data$race_hisp_2021,
                           metro_data$race_asian_2021,
                           metro_data$race_native_2021,
                           metro_data$race_pacific_2021,
                           metro_data$race_other_2021)) %>% 
    hc_add_series(name = paste0("Segment = ", as.character(zd$myclus)),
                  data = c(clus_data$race_white_2021,
                           clus_data$race_black_2021,
                           clus_data$race_hisp_2021,
                           clus_data$race_asian_2021,
                           clus_data$race_native_2021,
                           clus_data$race_pacific_2021,
                           clus_data$race_other_2021)) %>% 
    hc_title(text = "Racial/Ethnic Profile Comparison (%)", align = "left") %>% 
    hc_add_theme(hc_theme_smpl()) %>% 
    hc_tooltip(enabled = F)
  
  chart
  
})

highchartOutput("raceplot")

```

### Educational Attainment Profile, selected Zip code, Segment, and Metro Average (click on the map to show chart)

```{r}
output$eduplot <- renderHighchart({
  
  zd <- zip_data()
  
  # Set up metro data
  metro_data <- full_mapdat %>% st_drop_geometry() %>% 
    filter(metro_group == zd$metro_group) %>% 
    group_by(metro_group) %>% 
    summarise(across(c(starts_with("race") & ends_with("2021"), lessthan9_2021, highschool_2021,
                       college_2021, bachelor_2021, graduate_2021), ~ round(mean(.x, na.rm = T), 1)))
    
  # Set up segment data
  clus_data <- full_mapdat %>% st_drop_geometry() %>% 
    filter(myclus == zd$myclus) %>% 
    group_by(myclus) %>% 
    summarise(across(c(starts_with("race") & ends_with("2021"), lessthan9_2021, highschool_2021,
                       college_2021, bachelor_2021, graduate_2021), ~ round(mean(.x, na.rm = T), 1)))
    
  
  chart <- highchart() %>% 
    hc_chart(type = "column") %>% 
    hc_xAxis(categories = c("Less than High", "Highschool", "Some College", "Bacehlor", "Post Graduate"),
             title = list(text = 'Educational Attainment')) %>% 
    hc_yAxis(title = list(text = "%")) %>% 
    hc_plotOptions(series = list(dataLabels = list(enabled = T))) %>% 
    hc_add_series(name = paste0("Zip Code = ", as.character(zd$zcta)),
                  data = c(zd$lessthan9_2021,
                           zd$highschool_2021,
                           zd$college_2021,
                           zd$bachelor_2021,
                           zd$graduate_2021)) %>% 
    hc_add_series(name = paste0("Metro Group Average ", as.character(zd$metro_group)),
                  data = c(metro_data$lessthan9_2021,
                           metro_data$highschool_2021,
                           metro_data$college_2021,
                           metro_data$bachelor_2021,
                           metro_data$graduate_2021)) %>% 
    hc_add_series(name = paste0("Segment = ", as.character(zd$myclus)),
                  data = c(clus_data$lessthan9_2021,
                           clus_data$highschool_2021,
                           clus_data$college_2021,
                           clus_data$bachelor_2021,
                           clus_data$graduate_2021)) %>% 
    hc_title(text = "Educational Attainment Level Comparison (%)", align = "left") %>% 
    hc_add_theme(hc_theme_smpl()) %>% 
    hc_tooltip(enabled = F)
  
  chart
  
})

highchartOutput("eduplot")

```

Methods
=================================================

Column
-------------------------------------------------
### General Methods

#### Overview
We employed an analytic technique that searched for common demographic characteristics in markets across the U.S. In individual partner reports, we used those profiles to identify audience segments across the the publication's target markets. 

We combine data from various sources, including the U.S. Census and USDA. The resulting segment groups put publication target markets within a broader scope.

##### Audience Segment Assignment Process
```{r, echo=FALSE, out.width='100%'}
knitr::include_graphics("figs/method_fig1.png")
```

We created a total of **25 distinct segment groups.** Figure above visualizes the structure of these 25 segment groups and the overall process of segment group assignments. We assign one of the 25 segment groups to the publication target market ZIP codes. Below are how names of the segments are constructed. For detailed information about the segmentation scheme, please contact us.

In essence, what this procedure does is it allows you to see the broader picture of your target markets. For instance, if one is targeting 200 ZIP codes, after applying this scheme, one will be able to shrink 200 ZIP codes into, for example, 10 segment groups.

##### Audience Segment Naming Scheme
```{r, echo=FALSE, out.width='100%'}
knitr::include_graphics("figs/method_fig2.png")
```

Column
-------------------------------------------------
### Segment Descriptions
```{r, echo=FALSE}
description <- readxl::read_excel("data/seg_description.xlsx")
knitr::kable(description) %>% 
  kable_styling(bootstrap_options = c("striped", "condensed")) %>% 
  column_spec(1, bold = T) %>% 
  pack_rows("1: Metropolitan", 1, 12) %>% 
  pack_rows("2: Micropolitan", 13, 19) %>% 
  pack_rows("3: Small/Rural Towns", 20, 25)
```




